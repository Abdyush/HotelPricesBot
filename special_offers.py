import time
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver import Keys
from openai import OpenAI
import os
import re
import json
from datetime import datetime, timedelta
from dotenv import load_dotenv
from typing import Union, List, Dict, Tuple


#-------------------------------------------------------------------------- ПОДГОТОВИТЕЛЬНАЯ ЧАСТЬ ---------------------------------------------------------------------------------------

# Инициализируем словрь, в который будем добавлять категории
categories = {}
# Начало отсчета времени
start_time = time.time()
# большой словарь для хранения данных
all_offers = {}  
# Вызывааем функцию для считывания переменных из файла .env в окружение процееса
load_dotenv()


#-------------------------------------------------------------------------- НАБОР ФУНКЦИЙ ---------------------------------------------------------------------------------------------------

# Вспомогательная функция для получения атрибутов элемента (для процееса поиска необходимых элементов страницы)
def get_attributes(driver, element) -> dict:
    return driver.execute_script(
        """
        let attr = arguments[0].attributes;
        let items = {}; 
        for (let i = 0; i < attr.length; i++) {
            items[attr[i].name] = attr[i].value;
        }
        return items;
        """,
        element
    )
    
# Функция проверяет есть ли в строке информация о датах возможного бронирования и возвращает период броинрования в виде списка
# где первая дата это начало (сегодняшний день), а вторая - конец
def extract_date_before(text: str) -> Union[List[List[str]], None]:
    # Проверяем, есть ли в строке информация о проживании, если есть то это строка скорее всего содержит информацию о датах
    # проживания а не о датах бронирования, в таком случае возвращаем None
    if "проживани" in text.lower():
        return None
    
    # Определяем регулярное выражение для поиска дат
    date_pattern = r"\d{2}\.\d{2}\.\d{4}"
    # Ищем все даты в строке
    dates = re.findall(date_pattern, text)
    # Если дат нет, пропускаем строку возвращая None
    if not dates:
        return None  
    
    # Определяем сегодняшнюю дату
    today = datetime.today().strftime('%d.%m.%Y')
    # TODO: оптимизировать проверку
    # Если в строке есть слово бронирование и содержатся даты, значит вероятнее всего это нужная строка
    if "бронировани" in text.lower():
        # Если есть две даты, определяем их как начало и конец
        if len(dates) == 2:
            dates = [tuple(dates)]
        elif len(dates) == 1:
            dates = [(today, dates[0])]
        else:
            return None  # Если ничего не найдено, пропускаем строку
        
    # Возвращаем 
    return dates

# Функция ищет в строке даты проживания, определяемые специальным предложением        
def get_living_dates(string: str) -> Union[List[List[str]], None]:
    # Проверяем на наличие фразы о бронировании, если есть, занчит речь идет о датах бронироввания и нам не подходит
    if "бронировани" in string.lower():
        return None  # Если речь идет о бронировании, возвращаем None
    
    # Регулярное выражение для поиска дат
    date_pattern = r"\d{2}\.\d{2}\.\d{4}"
    # Ищем все даты в строке
    dates = re.findall(date_pattern, string)
    
    if not dates:
        return None  # Если дат нет, пропускаем строку
    
    # Определяем сегодняшнюю дату
    today = datetime.today().strftime('%d.%m.%Y')
    
    if len(dates) == 2:                # Если нашлось две даты, определяем их как начало и конец
        dates = [dates]
    elif len(dates) == 1:              # Если одна, то за начало берем сегодняшнюю дату, так как веротяно, в строке была дата определяющая, крайний день приживания
        dates = [[today, dates[0]]]
    elif len(dates) > 2:               # Если больше двух, то ншлись периоды, добавляем их списками в список
        dates = [list(date_pair) for date_pair in zip(dates[::2], dates[1::2])]
    else:
        return None                    # Если ничего не найдено, пропускаем строку
    
    # Возвращаем список дат проживания по спец предложению
    return dates

# Функция для спец предложения "Ранее бронирование", его суть в том, что скидка применяется если гость забронировал номер минимум за 60 суток до заезда
# таким образом, мы форматируем даты проживания прибавляя 60 суток к сегодняшнему дню и определяя переменную -  начало периода спец предложения
def early_booking(living_dates: List[list[str]]) -> List[list[str]]:
    for dates in living_dates:
        dates[0] = (datetime.now() + timedelta(days=60)).strftime('%d.%m.%Y')
    # Возвращаем обновленный список с датами 
    return living_dates

# Функция получение формулы расчетка стоимости суток со скидкой по специальному предложению, с помощью openai
def get_formula(offer: str) -> str:
    # Создаем промт, который будет вытаскивать формулу из переданной строки, в которой описана суть специального предложения
    promt = f'''Есть специальное предложение в отеле, вот оно {offer}, 
                нам известна стоимость номера за сутки.
                Прочитай специальное предложение, представь что все его условия выполнены, и извлеки суть в виде математической формулы, 
                которая рассчитывает итоговую стоимость номера за сутки, с учетом скидки.
                C - это стоимость за сутки без учета скидки, N - это стоимость номера ЗА СУТКИ с учетом скидки,
                если в формуле необходимо учесть количество дней, то подставь в формулу сразу цифру - минимально необходимое для скидки количество дней.
                Знак умножения в формуле обозначь так: '*',
                Ответ дай в виде формулы, БЕЗ ПОЯСНЕНИЙ'''
    
    # Здесь создается переменная client, которая будет содержать объект класса OpenAI. Этот объект используется для взаимодействия с API OpenAI.
    # в объект передается API-ключ, необходимый для аутентификации при обращении к API
    client = OpenAI(
        api_key=os.environ.get("OPENAI_API_KEY")
    )

    # Вызываем метод create для создания завершения (completion) чата. Результат этого вызова сохраняется в переменной completion.
    completion = client.chat.completions.create(
        model="gpt-4.1",                                       # указываем модель
        temperature=0.1,                                       # Параметр temperature контролирует степень случайности в ответах модели. Значение от 0 до 1. 
        max_tokens=100,                                        # Указывает максимальное количество токенов (слов и символов), которые могут быть сгенерированы в ответе.
        top_p=0,                                               # Параметр определяет диапазон разнообразия слов (для четкой формулы разнообразие не нужно)
        frequency_penalty=0,                                   # Параметр определяет частоту использования одних и тех же слов (нам нужен минимум)
        presence_penalty=0,                                    # Параметр штрафует слова за то, что оно уже встречалось (нам нужен минимум)
        messages = [{'role': 'system', 'content': promt}]      # Здесь задаются сообщения, которые передаются модели для контекста. 
    )                                                          # В данном случае передается одно сообщение с ролью system, которое содержит текст из переменной promt
        
    # Функция возвращает ответ модели в виде текста
    return completion.choices[0].message.content

# Функция читает строку спец предложения, и опрделеляет от сколько суток проживания оно действует
def get_min_days(text: str) -> str:
    # Создаем соответствующий промт
    promt = f'''Прочитай текст специального предложения в отеле: {text}
                и определи минимальное количетсво суток, которое необходимо забронировать гостю
                чтобы получить скидку.
                Ответ дай в формате "от трех ночей"'''
    
    client = OpenAI(
        api_key=os.environ.get("OPENAI_API_KEY")
    )

    # Вызываем метод create для создания завершения (completion) чата. Результат этого вызова сохраняется в переменной completion.
    completion = client.chat.completions.create(
        model="gpt-4.1",                                       # указываем модель
        temperature=0.1,                                       # Параметр temperature контролирует степень случайности в ответах модели. Значение от 0 до 1. 
        max_tokens=100,                                        # Указывает максимальное количество токенов (слов и символов), которые могут быть сгенерированы в ответе.
        top_p=0,                                               # Параметр определяет диапазон разнообразия слов 
        frequency_penalty=0,                                   # Параметр определяет частоту использования одних и тех же слов (нам нужен минимум)
        presence_penalty=0,                                    # Параметр штрафует слова за то, что оно уже встречалось (нам нужен минимум)
        messages = [{'role': 'system', 'content': promt}]      # Здесь задаются сообщения, которые передаются модели для контекста. 
    )                                                          # В данном случае передается одно сообщение с ролью system, которое содержит текст из переменной promt
    
    # Функция возвращает ответ модели в виде текста
    return completion.choices[0].message.content

# Функция определяющая на какие категории номеров, распространяется спец предложение
# TODO: оптимизировать функцию
def get_category(string: str) -> Union[str, List[str], None]:
    # Проверяем на наличие фразы "все категории вилл"
    if "все категории вилл" in string:
        return "Все виллы"
    # Проверяем на наличие фразы "все категории"
    elif "все категории" in string:
        return "Все категории"
    # Ищем отдельные категории
    else:
        # с помощью регулярного выражения, находим категории попадающие под шаблон (шаблон находить только первое слово после слова "категории")
        # TODO: оптимизировать поиск
        matches = re.findall(r'категории «(.*?)»', string)
        if matches:
            return matches  # Возвращаем найденные категории
        else:
            return None     # Ничего не найдено, пропускаем строку

# Функция определяет суммируется ли специальное предложение с программой лояльности или другими спец предложениями
# выяснилось, что с другими спецпредложениями никакая акция суммироваться не может, следовательно - нужно удалить данную проверку из функции
# TODO: оптимизировать функцию
def analyze_offers(line: str) -> Union[Tuple[bool], Tuple[None]]:
    # Инициализируем переменные "программа лояльности" и "другие спецпредложения"
    summ_loyalty = None
    summ_another_offers = None

    # Определяем перемнные, списки с возможными фразами свидетельствующими о суммировании
    nobody_options = ['не суммируется с программой лояльности и с другими спецпредложениями.',
                      'не суммируется с программой лояльности и другими спецпредложениями.']
    all_options = ['не суммируется с программой лояльности и с другими спецпредложениями.']
    loyalty = ['суммируется с программой лояльности']
    another_offers = ['суммируется с другими спецпредложениями']
    not_another_offers = ['не суммируется с другими спецпредложениями']
    not_loyalty = ['не суммируется с программой лояльности']
    
    # Если какая то из фраз перемнной nobody_options содержится в строке, это означает что спец предложение ни с чем не суммируется
    if any(phrase in line.lower() for phrase in nobody_options):
        summ_loyalty = False
        summ_another_offers = False
        return (summ_loyalty, summ_another_offers)
    # Если какая то из фраз перемнной all_options содержится в строке, это означает что спец предложение суммируется с п.л. и другими предложениями
    elif any(phrase in line.lower() for phrase in all_options):
        summ_loyalty = True
        summ_another_offers = True
        return (summ_loyalty, summ_another_offers)
    # Если фраза из списка not_another_offers есть в строке - преложение не суммируется с другими спецпредложениями, 
    # если фраза из списка loyalty есть в строке - преложение суммируется программой лояльности,
    # и при этом если фраз из списка not_loyalty нет в строке, это подтверждает утвержднение выше
    elif any(phrase in line.lower() for phrase in not_another_offers) and any(phrase in line.lower() for phrase in loyalty) and any(phrase not in line.lower() for phrase in not_loyalty):
        summ_loyalty = True
        summ_another_offers = False
        return (summ_loyalty, summ_another_offers)
    # Если фраза из списка not_loyalty есть в строке - преложение не суммируется с программой лояльности, 
    # если фраза из списка another_offers есть в строке - преложение суммируется с другими спецпредложениями,
    # и при этом если фраз из списка not_another_offers нет в строке, это подтверждает утвержднение выше
    elif any(phrase in line.lower() for phrase in not_loyalty) and any(phrase in line.lower() for phrase in another_offers) and any(phrase not in line.lower() for phrase in not_another_offers):
        summ_loyalty = False
        summ_another_offers = True
        return (summ_loyalty, summ_another_offers)
    # Если ничего выше не нашлось в строке, это означает что она не содержит релевантную информацию, возвращаем значения None в обеих перемнных
    else:          
        return (summ_loyalty, summ_another_offers)
        

#----------------------------------------------------------- ПАРСЕР ИНФОРМАЦИИ О СПЕЦИАЛЬНЫХ ПРЕДЛОЖЕНИЯХ С САЙТА ОТЕЛЯ -------------------------------------------------------------------------

#----------------------------------------------------------- Поиск кнопок на карточках спец предложений, и переходы по ним ----------------------------------------------------------------------
# Запускаем webdraiwer selenium под именем "browser"
with webdriver.Chrome() as browser:
    # Загружаем страницу официального сайта Мрии с всеми специальными предложениями
    browser.get('https://mriyaresort.com/offers/')
    # Спим 5 секунд 
    # TODO: Оптимизировать ожидание
    time.sleep(5)
    # Создаем список куда будут добавляться словари с информацией об офферах, дляпоследующей загрузки в json файл
    data_collection = []
    
    # Находим все карточки со специальными предложениями
    # TODO: Попробовать удалить этот поиск, так как ниже есть еще один
    cards = browser.find_elements(By.CLASS_NAME, 'card--action')
    # Запускаем цикл по длине списка с карточками офферов
    for i in range(len(cards)):
        # Создаем список lines в который будем добавлять все строки, для того чтобы целиком сформироовать весь текст оффера
        lines = []
        # Запускаем цикл на 10 итераций, чтобы пролистать вниз, так как кнопки на последних карточках,
        # расположеннные внизу страницы не кликаются
        for _ in range(10):
            # находим блок с тегом html
            block = browser.find_element(By.TAG_NAME, 'html')
            # и как бы поключившись к нему, имитируем нажатие клавиши вниз
            block.send_keys(Keys.DOWN)
            # Спим 1 секунду 
            # TODO: Оптимизировать ожидание
            time.sleep(1)
        
        # Зачем то снова находим все карточки, есть ли смысл искть их сверху?    
        cards = browser.find_elements(By.CLASS_NAME, 'card--action')
        # Дожидаемся максимум 10 секунд, пока станет клибальным первая кнопка в списке
        WebDriverWait(browser, 10).until(EC.element_to_be_clickable(cards[i]))
         # Прокручиваем к кнопке
        browser.execute_script("return arguments[0].scrollIntoView(true);", cards[i])
        # Кликаем по кнопке
        cards[i].click()
        # Спим 4 секунды 
        # TODO: Оптимизировать ожидание
        time.sleep(4)
        
        #-------------------------------------------------------------- Сбор всей информаци со страницы со спецпредложением -------------------------------------------------------------------
        # Находим элемет страницы где вероятно находиться навание оофера и присваиваем его переменной title
        title = browser.find_element(By.CLASS_NAME, 'f-h1')
        # Если название 'Подарочные сертификаты', пропускаем итерацию, так как это не спец предложение
        if title.text == 'Подарочные сертификаты':
            continue
        # Добавляем в список строку
        lines.append(title.text)
        # Переменной core присваиваем текст элемента, в котором обычно описывается суть спецпредложения, и указана скидка применимая к стоимости проживания
        core = browser.find_element(By.XPATH, "//div[contains(@class, 'block--content is_cascade')]/p")
        # Добавляем суть в список
        lines.append(core.text)
        # С помощью функции получаем формулу расчитывающую стоимость суток
        formula = get_formula(core.text)
        
        # Находим элемент, в котором содержаться строки с условиями спец предложения    
        ul_element = browser.find_element("xpath", "//*[text()='Условия']/following-sibling::ul")
        # Найти все теги <li> в найденном элементе <ul>
        li_elements = ul_element.find_elements("tag name", "li")

        # Получаем текст каждого найденного элемента <li>, записывая его в переменную 's'
        for li in li_elements:
            s = li.text
            # Добавляем строку в общий список
            lines.append(s)
            # Если в строке нашлась категория, присваем ее переменной category
            if get_category(s) != None:
                category = get_category(s)
            # Если в строке нашлись даты проживания, присваем их переменной living_dates
            if get_living_dates(s) != None:
                living_dates = get_living_dates(s)
                # Если название оффера "ранее бронирование", форматируем даты под условия спецпредложения
                if title.text == 'Раннее бронирование':
                    living_dates = early_booking(living_dates)
            # Если в строке нашлись даты бронирования, присваем их переменной date_before
            if extract_date_before(s) != None:
                date_before = extract_date_before(s)
            # Если в строке нашлась информация о суммировании скидок, присваиваем ее перемнной summ_offers
            if analyze_offers(s) != (None, None):
                summ_offers = analyze_offers(s)
                
        # Формируем единный строку со всей информацией о спецпредложении удаляя из нее не нужные боту строки
        offer_text = '\n'.join(lines)
        stop_phrase = ' только при обращении в единый контактный центр по номеру 8 800 550 52 71.'
        offer_text = offer_text.replace(stop_phrase, '.')
        
        # Передаем весь текст в функцию, где нейросеть находит минимальное количество дней проживания по офферу
        min_rest_days = get_min_days(offer_text)
        
        # Добавляем все данные в виде словаря в общий большой список
        data_collection.append({
                "Название": title.text,  # Преобразуем дату в строку
                "Категория": category,
                "Даты проживания": living_dates,
                "Даты бронирования": date_before,
                "Формула расчета": formula,
                "Минимальное количество дней": min_rest_days,
                "Суммируется с программой лояльности": summ_offers[0],
                "Суммируется с другими специальными предложениями": summ_offers[1],
                "Текст предложения": offer_text
                })
        
        #-------------------------------------------------------------- Возвращение к странице со всеми офферами -----------------------------------------------------------------------------
        # Находим элемент со ссылкой на страницу со всеми офферами и кликаем по нему
        link_element = browser.find_element(By.CSS_SELECTOR, "a[href='/offers']")
        link_element.click()
        # Спим 5 секунд 
        # TODO: Оптимизировать ожидание
        time.sleep(4)

#----------------------------------------------------------------- ЗАПИСЬ ДАННЫХ В ФАЙЛ И ЗАВЕРШЕНИЕ РАБОТЫ ----------------------------------------------------------------------------------- 
     
# Запись данных в JSON файл после завершения цикла
with open('data_offers.json', 'w', encoding='utf-8') as json_file:
    json.dump(data_collection, json_file, ensure_ascii=False, indent=4)  # Записываем данные в JSON формат
    
# Конец отсчета времени
end_time = time.time()
execution_time = end_time - start_time

# Преобразование времени выполнения в минуты и секунды
minutes = int(execution_time // 60)
seconds = int(execution_time % 60)

# Выводим в консль отчет о выполнении программы и итоговое время
print("Данные успешно сохранены в data_offers.csv")
print(f"Время выполнения программы: {minutes} минут {seconds} секунд")